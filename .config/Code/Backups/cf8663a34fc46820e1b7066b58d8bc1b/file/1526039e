file:///home/buddhilw/PP/facti/linfo-fresh/pdfPC/README.md {"mtime":1675163382492,"ctime":1674644903474,"size":5386,"etag":"3a36p6i5k5in","orphaned":false,"typeId":""}
# Gerar PDF para a Prestação de Contas 

**Não confundir com a PC Histórica**.

## Como a aplicação foi configurada

Foi configurado no `shadow.edn` (a là `json`), que a aplicação inicia da seguinte forma: 

- `source-paths`: onde o código Clojure se encontra, em `src`.
- `reagent`: um wrap (enrolamento) no React. 
- `nrepl`: lisps são linguagens interpretadas. Isso significa que é possível avaliar código, enquanto a aplicação roda e desenvolver interativamente. O `nrepl` é o terminal que Read, Evaluate, Print e Loop (REPL), isso é, Lê código, Computa, Imprime o resultado e Reinicia o cíclo. Ele estará rodando na porta `3333`.
Dependências:
- `dev-http`: `Servidor` serve na porta `3001`, em desenvolvimento. Basta rodar `npm run dev`, dentro do diretório `<pasta-do-projeto>/pdfPC`. A raíz do projeto foi determinada como `../public`, para onde se envia as mudanças de estado ao arquivo `gerarPdfPc-NaoHistorica.html`, e serve-nos de ponto-de-entrada da aplicação.
- `builds`: Pode-se configurar várions perfis de builds, por exemplo, uma pra teste, outra pra dev, outra pra produção. É onde especificamos, também, onde o arquivo compilado se encontrará. Em desenvolvimento, esse arquivo constantemente mudará, a cada mudança de em um arquivo, sob o diretório `src`. 
- `:modules {:main {:entries [app.core]}}` especifica que a aplicação possui instruções de inicialização no `namespace (ns)`, ou aquivo, `app.core` [caminho: `src/app/core.cljs`].

``` clj
{:source-paths ["src"]

 :dependencies [[binaryage/devtools "1.0.6"]
                [reagent "1.1.1"]]

 :nrepl        {:port 3333}

 :dev-http
 {3001 {:root "../public"
        :push-state/index "gerarPdfPC-NaoHistorica.html"}}

 :builds
 {:app {:target :browser
        :output-dir "../public/js/gerarPdfPC-NaoHistorica/"
        :asset-path "/js"

        :modules
        {:main
         {:entries [app.core]}}}}}

```

## Como que a aplicação se integra ao `LINFO-PPI`?

Ao se clicar no ícone de gerar pdf, na aba de Prestação de Contas, chama-se um router que direciona o usuário a um html chamado `gerarPdfPc-NaoHistorica.html`, onde o HTML possui a tag injetora de JavaScript, advinda da nossa aplicação.

``` html
    <body>
        <div id="app"></div> <!-- div#app em que nossa aplicação e montada -->
        <script type="text/javascript" src="./js/gerarPdfPC-NaoHistorica/pcNaoHistorica.js"></script>    <!-- onde se faz o fetch dos dados da PC (javascript vanilla) -->
        <script src="/js/gerarPdfPC-NaoHistorica/main.js" type="text/javascript"></script>               <!-- Nossa aplicação compilada -->
    </body>
```

## Como a aplicação Clojure se estrutura  

``` bash
tree src/
```

``` bash
src/
├── app
│   ├── core.cljs
│   ├── events.cljs
│   ├── state.cljs
│   ├── views
│   │   ├── cabecalho
│   │   │   ├── header.cljs
│   │   │   └── titulo.cljs
│   │   └── drd
│   │       ├── infos.cljs
│   │       └── titulo.cljs
│   └── views.cljs
└── test
    └── core.cljs
```

No arquivo `core.cljs`, é onde se especifica como a aplicação deve ser montada e atualizada a *view* (em modo desenvolvimento).

- `(ns app.core)`: onde se chama as dependencias para o `namespace`, podendo ser eles modulos advindos do javascript (npm) ou pacotes clojure, como o `reagent`, ou então outros arquivos dentro do mesmo projeto. As dependências são chamadas pelos seus `ns`.
- `(gdom/getElement "app")`: usamos a biblioteca `goog.dom`, desenvolvida pela Google, para pegar o elemento com id app (`div#app`).
- `(rdom/render [views/app] el)`: chamamos o `reagent` para montar nosso `view/app` sob o elemento `el` (ainda não especificado).
- `mount-app-element`: essa função juntará as duas anteriores para montar o `view/app` em cima da `div#app`.
- `(mount-app-element)`: é a chamada para se iniciar o app, em si [^1].

``` cljs
(ns app.core
  (:require [reagent.core :as r]
            [app.state :as state]
            [app.views :as views]
            [goog.dom :as gdom]
            [goog.object]
            [reagent.dom :as rdom]))

(defn get-app-element []
  (gdom/getElement "app"))

(defn mount [el]
  (rdom/render [views/app] el))

(defn mount-app-element []
  (when-let [el (get-app-element)]
    (mount el)))

;; Condicionalmente, inicia a aplicação, baseado na presença do elemento "app"
;; particularmente útil para testar esse name-space (ns), sem inicializar a aplicação.
(mount-app-element)

;; Specifica o hook do (hot)reload, utilizando-se a meta-tag ^:after-load
(defn ^:after-load on-reload []
  (mount-app-element))
```


## Referencias e notas
[^1] NOTA: 

O código,
``` cljs
(defn ^:after-load on-reload []
  (mount-app-element))
```

Define o que deve ser feito, quando o hot-reload atualiza a aplicação. Em nosso caso, remontar a aplicação sob o `div#app` (a là react, e com todas suas optimizações).

Não foi mencionado o papel da função `mount`. Porém, ela é uma função nativa de ClojureScript, e faz com que seja desnecessário utilizar uma tag no HTML, onde a aplicação será rodada, com uma instrução de inicialização da aplicação. 

E.g.,

``` html
<script>window.onload= function() { app.core.main(); }</script>
```
